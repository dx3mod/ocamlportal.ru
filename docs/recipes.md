# Рецепты

## Labels

Изначально стандартная библиотека не сильно использует возможности именованных аргументов, поэтому существует модули-двойники.

Например, `List` и `ListLabels`. Различие в сигнатуре функции `map`:

```ocaml
(* list.mli *)
val map : ('a -> 'b) -> 'a list -> 'b list

(* listLabels.mli *)
val map : f:('a -> 'b) -> 'a list -> 'b list
```

Подход именованных аргументов позволяет не заботиться о позиции аргументов, что актуально при композиции.

Подобный подход лёг в основу некоторых альтернативных стандартных библиотек, вроде [`Base`](./libraries/core/base.md).

## Channels

Канала (channels) это пара модулей (`In_channel` и `Out_channel`) из стандартной библиотеке, абстрагирующие работу с файловыми потоками ввода-выводами.

### Именование

Сокращать название переменных можно до `oc` (`Out_channel`) и `ic` (`In_channel`), либо просто `ch`.

### Рекомендации

Предпочитайте открытие _канала_ при помощи функций `with_open_*`, так как в случае исключения они безопасно закроют файл.

#### Пример

```ocaml
let () =
  In_channel.with_open_text "some.file" @@ fun ic -> (* ... *)
```

## Монадика

Про монады можно почитать в [8.7. Monads](https://cs3110.github.io/textbook/chapters/ds/monads.html).

### Операторы

<!-- Де-факто зачастую используются подобные операторы: -->

Смотрите [Binding operators](https://ocaml.org/manual/bindingops.html).

| Операторы             | Функция | Описание                                                              |
| --------------------- | ------- | --------------------------------------------------------------------- |
|                       |         |                                                                       |
| `>>=`, `let*`         | `bind`  | Монадическое связывание, определяющие монадическую последовательность |
| `>>\|`, `>\|=` `let+` | `map`   | Отображение (между двумя категориями)                                 |

> [!NOTE] Историческая справка
> Начиная с версии 4.08 появилась возможность определять `let-in` конструкцию.

#### Пример

```ocaml
let (let+) o f = Option.map f o
let (and+) ao bo = Option.bind ao (fun a -> let+ b = bo in a, b)

let map2 f xo yo =
  let+ x = xo
  and+ y = yo in
  f x y

(* - ('a -> 'b -> 'c) -> 'a option -> 'b option -> 'c option = <fun> *)
```

### ppx

Для некоторых библиотек, вроде [`lwt`](./libraries/concurrency/lwt.md), делают ppx-расширения.

## Backtrace recording

По-умолчанию отслеживание бектрейса исключений **выключено**.

> [!IMPORTANT] Вопрос производительности
> Включение _backtrace recording_ может сказаться на производительности при обильном использование исключений в вашей программе.

> [!NOTE] Рекомендации
> Используйте backtrace recording исключительно во время разработки.

### Включение

Чтобы его включить можно воспользоваться переменной окружения, либо явно вызвав функцию в коде.

```sh
# in shell
$ OCAMLRUNPARAM=b ocaml main.ml
```

```ocaml
(* in code *)
Printexc.record_backtrace true
```

### Результат

До и после.

```
Fatal error: exception Not_found

Fatal error: exception Not_found
Raised at Dune__exe__Main in file "bin/main.ml", line 6, characters 8-23
```
