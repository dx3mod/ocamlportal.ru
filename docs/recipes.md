# Рецепты

Список рецептов.

## Labels

Использование _именованных аргументов_ ([labeled arguments](https://ocaml.org/manual/lablexamples.html)) зачастую предпочтительнее, если ваша функция принимает три и более параметра.

> [!NOTE] Пример
> В стандартной библиотеке для некоторых модулей существуют модули-двойники, использующие подход именованных аргументов.
>
> ```ocaml
> (* Bytes.sub *)
> val sub : bytes -> int -> int -> bytes
>
> (* BytesLabels.sub *)
> val sub : bytes -> pos:int -> len:int -> bytes
> ```

Преимущества:

- Больше информации в сигнатуре
- Более гибкая возможность композиции функций

## Channels

Канала (channels) это пара модулей (`In_channel` и `Out_channel`) из стандартной библиотеке, абстрагирующие работу с файловыми потоками.

> [!NOTE] Именование
> Сокращать название каналов можно до `oc` (`Out_channel`) и `ic` (`In_channel`). Либо используйте осознанные имена, вроде `config_file`.

> [!NOTE] Безопасная работа
> Предпочитайте открытие _канала_ при помощи функций `with_open_*`, так как в случае исключений они безопасно закроют файл.
>
> ```ocaml
> let () =
>   In_channel.with_open_text "some.file" @@ fun ic -> (* ... *)
> ```

## Монадика

Про монады можно почитать в [8.7. Monads](https://cs3110.github.io/textbook/chapters/ds/monads.html).

### Операторы

Смотрите [Binding operators](https://ocaml.org/manual/bindingops.html).

| Операторы             | Функция | Описание                                                              |
| --------------------- | ------- | --------------------------------------------------------------------- |
|                       |         |                                                                       |
| `>>=`, `let*`         | `bind`  | Монадическое связывание, определяющие монадическую последовательность |
| `>>\|`, `>\|=` `let+` | `map`   | Отображение (между двумя категориями)                                 |

> [!NOTE] Историческая справка
> Начиная с версии 4.08 появилась возможность определять `let-in` конструкцию.

> [!NOTE] Пример
>
> ```ocaml
> let (let+) o f = Option.map f o
> let (and+) ao bo = Option.bind ao (fun a -> let+ b = bo in a, b)
>
> let map2 f xo yo =
>   let+ x = xo
>   and+ y = yo in
>   f x y
>
> (* - ('a -> 'b -> 'c) -> 'a option -> 'b option -> 'c option = <fun> *)
> ```

### ppx

Для некоторых библиотек, вроде [`lwt`](./libraries/concurrency/lwt.md), делают ppx-расширения.

> [!NOTE] Пример
>
> ```ocaml
> let%lwt users = get_users_from_db ()
> (* Lwt.bind (get_users_from_db ()) @@ fun users -> ... *)
> ```

## Монады vs исключения

Всё зависит от вашего стиля написания кода.

> [!TIP] Когда и что использовать
> Используйте **исключения для фатальных ошибок**, либо ошибок, которые зачастую не произойдут. **Монады для ожидаемых ошибок**, ошибок бизнес-логики, вроде некорректных данных от пользователя и т.д..

> [!NOTE] Двойники
> Иногда для удобства делают функции-двойники (с суффиксом `_exn`), которые выкидывают исключение в случае ошибки.

### Монады

> [!NOTE] Преимущества
>
> - Кодируются в сигнатуре функции (про них сложно "забыть")
> - Требуют явной обработки, либо использования [монадики](#монадика)

## Backtrace recording

По-умолчанию отслеживание бектрейса исключений **выключено**.

> [!IMPORTANT] Вопрос производительности
> Включение _backtrace recording_ может сказаться на производительности при обильном использование исключений в вашей программе.

> [!TIP] Рекомендации
> Используйте backtrace recording исключительно во время разработки.

Чтобы включить отслеживание можно воспользоваться переменной окружения, либо явно вызвав функцию в коде.

```sh
# in shell
$ OCAMLRUNPARAM=b ocaml main.ml
```

```ocaml
(* in code *)
Printexc.record_backtrace true
```

> [!NOTE] Результат
> До и после.
>
> ```
> Fatal error: exception Not_found
>
> Fatal error: exception Not_found
> Raised at Dune__exe__Main in file "bin/main.ml", line 6, characters 8-23
> ```

## Unsafe

В стандартной библиотеке можно встретить `unsafe_` функции, такие функции ориентированны на опытных пользователей и при правильном использование способы повысить производительность за счёт ручного контроля.

> [!IMPORTANT] Преждевременная оптимизация
>
> > Преждевременная оптимизация — корень всех зол.
>
> Старайтесь покрывать тестами участки кода, зависимые от unsafe преобразований.

### Zero-cost преобразование

Основной паттерн таких функций это понятие _владения_ (или уникальности), которое мы должны гарантировать.

Типичный пример &mdash; мы хотим преобразовать `bytes` в строку. Если воспользоваться функцией `Bytes.to_string`, то она создаст копию, преобразует её в строку и вернёт эту копию.

> [!NOTE] Почему жто так?
> Дело в том, что `bytes` это изменяемая (mutable) структура данных, а строки &mdash; нет. Из-за чего если мы не скопируем значение, то при изменение `bytes` будет изменяться и строка, а это не то поведение, что мы хотели бы, это было бы нарушением абстракций.
>
> Демонстрация:
>
> ```ocaml
> let () =
>   let b = Bytes.make 10 'a' in (* "aaaaaaaaaa" *)
>   let s = string_of_bytes b in (* "aaaaaaaaaa" *)
>
>   Bytes.set b 2 'B';
>
>   print_endline s (* aaBaaaaaaa *)
> ```

Но если мы **уверены** и готовы **гарантировать**, что исходный объект не будет изменяться, то можем сделать `unsafe_to_string`, которые не произведет никаких новых выделений памяти, а просто вернёт новый тип для того же объекта.

### Unchecked

Другой распространённый паттерн &mdash; unchecked доступ (обычно к элементам коллекций). Такой доступ не проверяет выход за пределы буфера и не гарантирует какую-либо безопасность.

> [!TIP] Итерация
> По возможности используйте итерацию, а не явный цикл.

> [!NOTE] Пример с массивом
>
> ```ocaml
> let () =
>   let arr = [|"первый"; "второй" |] in
>   print_endline @@ Array.unsafe_get arr 3;
>   Array.unsafe_set arr 3 "третий";
>   print_endline @@ Array.unsafe_get arr 3
> ```

::: details В ассемблере
Unchecked.

```ocaml
let x = Array.unsafe_get arr 1
(* movq    8(%rax), %rax *)
```

Checked.

```ocaml
let x = arr.(1)
(* movq    -8(%rax), %rbx
   cmpq    $2047, %rbx
   jbe     .L104
   movq    8(%rax), %rax *)
```

:::
